package myProject

class Controller(view:View,model:Model) {
  var gameStructure= new Structure
  var input= -1
  def SHOW_PLAYING_AREA{
    view.showPlayingArea
  }
  def SHOW_PLAYER_ORDER= ???
  def ADVANCE_ORDER= ???
  def WINNER_CHECK= ???
  def DO_MOVE= ???
  def DO_TURN= ???
  def DO_GAME= ???
  def INIT{
    view.MainMenu
    
    
    
  }
  while(input!=9) {
    if (input==0) view.help
    else if (input==1) SHOW_PLAYING_AREA
    else if (input==2) SHOW_PLAYER_ORDER
    else if (input==3) ADVANCE_ORDER
    else if (input==4) INIT
    else if (input==5) WINNER_CHECK
    else if (input==6) DO_MOVE
    else if (input==7) DO_TURN
    else if (input==8) DO_GAME
    else view.error
    input=readInt()
  }
  view.exit
  
  class Structure{
  val scoreBoard = new model.Scoreboard
  val hand1= new model.Hand(0)
  val hand2= new model.Hand(1)
  val hand3= new model.Hand(2)
  val hand4= new model.Hand(3)
  var handArray=Array.ofDim[Hand](4)
  var playArea=new PlayArea
  val queue= new TurnQueue
  val twoHeart=new Card(2,"Heart")
  val threeHeart=new Card(3,"Heart")
  val fourHeart=new Card(4,"Heart")
  val fiveHeart=new Card(5,"Heart")
  val sixHeart=new Card(6,"Heart")
  val sevenHeart=new Card(7,"Heart")  
  val eightHeart=new Card(8,"Heart")
  val nineHeart=new Card(9,"Heart")
  val tenHeart=new Card(10,"Heart")
  val jackHeart=new Card(11,"Heart") 
  val queenHeart=new Card(12,"Heart")
  val kingHeart=new Card(13,"Heart")
  val aceHeart=new Card(14,"Heart")
  val twoSpade=new Card(2,"Spade")
  val threeSpade=new Card(3,"Spade")
  val fourSpade=new Card(4,"Spade")
  val fiveSpade=new Card(5,"Spade")
  val sixSpade=new Card(6,"Spade")
  val sevenSpade=new Card(7,"Spade")  
  val eightSpade=new Card(8,"Spade")
  val nineSpade=new Card(9,"Spade")
  val tenSpade=new Card(10,"Spade")
  val jackSpade=new Card(11,"Spade") 
  val queenSpade=new Card(12,"Spade")
  val kingSpade=new Card(13,"Spade")
  val aceSpade=new Card(14,"Spade")
  val twoClub=new Card(2,"Club")
  val threeClub=new Card(3,"Club")
  val fourClub=new Card(4,"Club")
  val fiveClub=new Card(5,"Club")
  val sixClub=new Card(6,"Club")
  val sevenClub=new Card(7,"Club")  
  val eightClub=new Card(8,"Club")
  val nineClub=new Card(9,"Club")
  val tenClub=new Card(10,"Club")
  val jackClub=new Card(11,"Club") 
  val queenClub=new Card(12,"Club")
  val kingClub=new Card(13,"Club")
  val aceClub=new Card(14,"Club")
  val twoDiamond=new Card(2,"Diamond")
  val threeDiamond=new Card(3,"Diamond")
  val fourDiamond=new Card(4,"Diamond")
  val fiveDiamond=new Card(5,"Diamond")
  val sixDiamond=new Card(6,"Diamond")
  val sevenDiamond=new Card(7,"Diamond")  
  val eightDiamond=new Card(8,"Diamond")
  val nineDiamond=new Card(9,"Diamond")
  val tenDiamond=new Card(10,"Diamond")
  val jackDiamond=new Card(11,"Diamond") 
  val queenDiamond=new Card(12,"Diamond")
  val kingDiamond=new Card(13,"Diamond")
  val aceDiamond=new Card(14,"Diamond")
  var round=0
  var lastHandWentTo= -1
  
  
  def NewRound={
    val standardDeck = new Deck("Standard",Stack[Card](twoHeart,threeHeart,fourHeart,fiveHeart,sixHeart,sevenHeart,
    eightHeart,nineHeart,tenHeart,jackHeart,queenHeart,kingHeart,aceHeart,twoSpade,threeSpade,
    fourSpade,fiveSpade,sixSpade,sevenSpade,eightSpade,nineSpade,tenSpade,jackSpade,queenSpade,
    kingSpade,aceSpade,twoClub,threeClub,fourClub,fiveClub,sixClub,sevenClub,eightClub,nineClub,
    tenClub,jackClub,queenClub,kingClub,aceClub,twoDiamond,threeDiamond,fourDiamond,fiveDiamond,
    sixDiamond,sevenDiamond,eightDiamond,nineDiamond,tenDiamond,jackDiamond,queenDiamond,kingDiamond,aceDiamond))
    standardDeck.shuffle
    hand1.draw(standardDeck)
    hand2.draw(standardDeck)
    hand3.draw(standardDeck)
    hand4.draw(standardDeck)
    handArray(0)=hand1
    handArray(1)=hand2
    handArray(2)=hand3
    handArray(3)=hand4
    round=1
    }
  def loadQueue={
    if (round<=1){
      if (hand1.cardSet.contains(twoClub)) queue.load(0)
      else if (hand2.cardSet.contains(twoClub)) queue.load(1)
      else if (hand3.cardSet.contains(twoClub)) queue.load(2)
      else queue.load(3)
    }
    else queue.load(lastHandWentTo)
  }
  def doFirstTurn(seat:Int, playArea:PlayArea){
    val playedCard=handArray(seat).play("Any")
    playArea.lead=playedCard.suit
    playArea.assignCard(seat,playedCard)
  }
  def doRegularTurn(seat:Int,playArea:model.PlayArea){
    val playedCard=handArray(seat).play(playArea.lead)
    playArea.assignCard(seat,playedCard)
  }
  
  def showQueue{
    println("the queue is: ")
    for (x<- queue) println(x)
  }
  
  def completeTrick{
    println("Full Turn")
    loadQueue
    //showQueue
    playArea=new PlayArea
    var currTurn=queue.dequeue
    doFirstTurn(currTurn, playArea)
    //println("the first card played at index "+currTurn.toString+" is: "+playArea.cards(currTurn).rank+" "+playArea.cards(currTurn).suit)
    
    currTurn=queue.dequeue
    doRegularTurn(currTurn,playArea)
    //println("the second card played at index "+currTurn.toString+" is: "+playArea.cards(currTurn).rank+" "+playArea.cards(currTurn).suit)
    
    currTurn=queue.dequeue
    doRegularTurn(currTurn,playArea)
    //println("the third card played at index "+currTurn.toString+" is: "+playArea.cards(currTurn).rank+" "+playArea.cards(currTurn).suit)
    
    currTurn=queue.dequeue
    doRegularTurn(currTurn,playArea)
    //println("the last card played at index "+currTurn.toString+" is: "+playArea.cards(currTurn).rank+" "+playArea.cards(currTurn).suit)

    val score=playArea.calculateScore
    println("the score of the pile is: "+score.toString)
    
    scoreBoard.addScore(playArea.max,score)
    
    println("the player at index "+playArea.max.toString+" would take the pile")
    lastHandWentTo=playArea.max
    round=round+1
    println("")
  }
  def completeRound{
    println("Full Round")
    while (handArray(0).cardSet.size+handArray(1).cardSet.size+handArray(2).cardSet.size+handArray(2).cardSet.size>0){
        completeTrick
        }
    if (scoreBoard.loserCheck==false){
      NewRound
      println("------------------------------------------")
      println("Round Complete the score is:")
      println("Player 1: "+scoreBoard.scores(0).toString)
      println("Player 2: "+scoreBoard.scores(1).toString)
      println("Player 3: "+scoreBoard.scores(2).toString)
      println("Player 4: "+scoreBoard.scores(3).toString)
      println("")
    }
    else {
    println("")
    println("GAME OVER")
    if (scoreBoard.winner==0) println("player1 wins")
    else if (scoreBoard.winner==1) println("player2 wins")
    else if (scoreBoard.winner==2) println("player3 wins")
    else println("player4 wins")
    }
  }
  def completeGame{
    println("Full Game")
    while (scoreBoard.loserCheck==false){
      completeRound
    } 
  }