package myProject

import org.scalatest.FunSpec
import org.scalatest.Matchers

class heartsTest extends FunSpec with Matchers {

  describe ("a Deck"){
    describe("before a hand"){
      it("has 52 cards"){
      val deck= new Deck("standard", null)
      assert (deck.length==52)  
      }
      
      it("has no repeated elements"){
        val deck= new Deck("standard",null)
        var mover=Set[Card]()
        while (!deck.isEmpty) mover+=deck.deal
        assert (mover.size==52)
        }
      
      it("is shuffled"){
        val deck = new Deck("standard",null)
        val copyDeck= deck
        deck.shuffle
        assert (deck.showContents!=copyDeck.showContents)
      }
      }
    describe("after dealt"){
      it("is empty"){
      var deck= new Deck("standard",null)
      assert (deck.length==0)
      }
    }
  }
  
  describe("a player's Hand"){
   
    describe("at the start of a hand"){
      it ("has 13 cards"){
        val hand=new Hand(0)
        assert (hand.cardSet.size==13)
      }

    }
    

      it ("has the number of cards equal to 13-(the round number)"){
        val hand=new Hand(0)
        val sim=new SimControll
        val roundNumber=sim.round
        assert (roundNumber==(13-hand.cardSet.size))
      }
      it ("does not contain cards that were just played"){
        val hand=new Hand(0)
        val playArea=new PlayArea
        val test=hand.play("Heart")
        playArea.assignCard(hand.seat,test)
        assert(!hand.cardSet.contains(playArea.cards(hand.seat)))
      }
    }
//Deleted the discard pile because it can be logically worked around.
  

  describe("a Card"){
    it("has a rank and a valid suit"){
      val card=new Card(-1, null)
      assert (card.isValid)
    }
  }
  describe("the play area"){//must have an array and a point value associated with it, lead suit?
    it("determines the index of the highest ranking card"){
      val play= new PlayArea
      var best= 0
      for (index<-0 until play.cards.length){
        if (play.cards(index).suit==play.lead){
          if (play.cards(index).rank>best) best=index
        }
      }
      assert(best==play.max)
    }
    it("ensures all cards are valid"){
      val play= new PlayArea
      var flag=true
      for (card<-play.cards){
        if (!card.isValid) flag=false
      }
      assert(flag)
    }
    it("Tracks the points acquired in the pot"){
      val play= new PlayArea(0,null)
      assert (play.score>=0)
    }
  }
  describe("a Scoreboard"){
    it("checks for a loser"){
      val score =new Scoreboard
      score.init
      score.loserCheck(score.scores) should be (false)
      score.scores(0)=100
      score.loserCheck(score.scores) should be (true)
    }
    it("initializes at zero"){
      val score =new Scoreboard
      score.init
      for (item<-score.scores) item should be (0)
    }
  }
  describe("turn queue"){
    it("analyzes each player's hand for who has the 2 of clubs at the beginning of the game"){fail}
    it("tracks which player took the pile in the previous round"){fail}
    it("calculates player order based on who took the pile last/who has the 2 of clubs"){fail}
    it("determines which player is to the left of a given player"){fail}
    it("determines which player is to the right of a given player"){fail}
    it("determines which player is across from a given player"){fail}
  }
  describe("the Mover"){
    it("advances the player order"){fail}
    it("tracks when the round is complete"){fail}
    it("gives the pile to the appropriate player"){fail}
  }
  describe("Background processes"){
    it("initializes the game"){fail}
    it("checks for a winner following every hand"){fail}
    
  }
}

